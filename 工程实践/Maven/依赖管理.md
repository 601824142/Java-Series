# Maven 中的依赖管理

依赖管理是 Maven 的一大特征，对于一个简单的项目，对依赖的管理并不是什么困难的事，但是如果这个项目依赖的库文件达到几十个甚至于上百个的时候就不是一个简单的问题了。在这个时候 Maven 对于依赖管理的作用就显露出来了。下面主要讨论几个方面的内容：传递性依赖，依赖范围，依赖管理，系统依赖，可选依赖

Maven 使用 dependencyManagement 元素来提供了一种管理依赖版本号的方式。通常会在一个组织或者项目的最顶层的父 POM 中看到 dependencyManagement 元素。使用 pom.xml 中的 dependencyManagement 元素能让所有在子项目中引用一个依赖而不用显式的列出版本号。Maven 会沿着父子层次向上走，直到找到一个拥有 dependencyManagement 元素的项目，然后它就会使用在这个 dependencyManagement 元素中指定的版本号。

例如在父项目里：

```xml
<dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>5.1.2</version>
    </dependency>
    ...
  <dependencies>
</dependencyManagement>
```

然后在子项目里就可以添加 mysql-connector 时可以不指定版本号，例如：

```xml
<dependencies>
  <dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
  </dependency>
</dependencies>
```

同时在 dependenceManagement 种，也可以从外部导入 POM 文件中的依赖项：

```xml
<dependencyManagement>
     <dependencies>
        <dependency>
            <!-- Import dependency management from Spring Boot -->
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>1.3.0.RC1</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

# Dependency Scope

Maven 有三套 classpath(编译 classpath，运行 classpath，测试 classpath)分别对应构建的三个阶段。依赖范围就是控制依赖与这三套 classpath 的关系。依赖范围有六种。在 POM 4 中，`<dependency>` 中还引入了 `<scope>`，它主要管理依赖的部署。目前 `<scope>` 可以使用 5 个值:

- compile，缺省值，适用于所有阶段，会随着项目一起发布。compile 是默认的范围；如果没有提供一个范围，那该依赖的范围就是编译范围。编译范围依赖在所有的 classpath 中可用，同时它们也会被打包。

- provided，provided 依赖只有在当 JDK 或者一个容器已提供该依赖之后才使用。例如，如果你开发了一个 web 应用，你可能在编译 classpath 中需要可用的 ServletAPI 来编译一个 servlet，但是你不会想要在打包好的 WAR 中包含这个 ServletAPI；这个 Servlet API JAR 由你的应用服务器或者 servlet 容器提供。已提供范围的依赖在编译 classpath(不是运行时)可用。它们不是传递性的，也不会被打包。

- runtime， runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要 JDBC API JAR，而只有在运行的时候才需要 JDBC 驱动实现。

- test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。

- system，system 范围依赖与 provided 类似，但是你必须显式的提供一个对于本地系统中 JAR 文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构件应该是一直可用的，Maven 也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个 systemPath 元素。注意该范围是不推荐使用的(你应该一直尽量去从公共或定制的 Maven 仓库中引用依赖)。

```xml
<project>
  ...
  <dependencies>
    <dependency>
      <groupId>javax.sql</groupId>
      <artifactId>jdbc-stdext</artifactId>
      <version>2.0</version>
      <scope>system</scope>
      <systemPath>${java.home}/lib/rt.jar</systemPath>
    </dependency>
  </dependencies>
  ...
</project>
```

## 使用 system 依赖范围

在下文中会有对于依赖的 scope 的详细解释，这里只需要知道如果将 scope 设置为了 system 即是自动在本地路径中寻找依赖的 Jar 包即可。

```xml
<dependency>
  <groupId>dnsns</groupId>
  <artifactId>dnsns</artifactId>
  <version>1.0</version>
  <scope>system</scope>
  <systemPath>${project.basedir}/src/lib/dnsns.jar</systemPath>
</dependency>
<dependency>
  <groupId>localedata</groupId>
  <artifactId>localedata</artifactId>
  <version>1.0</version>
  <scope>system</scope>
  <systemPath>${project.basedir}/src/lib/localedata.jar</systemPath>
</dependency>
<dependency>
  <groupId>sunjce_provider</groupId>
  <artifactId>sunjce_provider</artifactId>
  <version>1.0</version>
  <scope>system</scope>
  <systemPath>${project.basedir}/src/lib/sunjce_provider.jar</systemPath>
</dependency>
<dependency>
  <groupId>sunpkcs11</groupId>
  <artifactId>sunpkcs11</artifactId>
  <version>1.0</version>
  <scope>system</scope>
  <systemPath>${project.basedir}/src/lib/sunpkcs11.jar</systemPath>
</dependency>
```

# Dependency Mediation | 依赖调停

![](http://www.yiibai.com/uploads/allimg/131228/212042K00-0.jpg)

传递性依赖是在 Maven 中添加的新特征，这个特征的作用就是你不需要考虑你依赖的库文件所需要依赖的库文件，能够将依赖模块的依赖自动的引入。例如我们依赖于 Spring 的库文件，但是 Spring 本身也有依赖，如果没有传递性依赖那就需要我们了解 Spring 项目依赖，然后也要添加到我们的项目中。

由于没有限制依赖的数量，如果出现循环依赖的时候会出现问题，这个时候有两种方式处理，一种是通过 build-helper-maven-plugin 插件来规避，另一种就是重构两个相互依赖的项目。通过传递性依赖，项目的依赖结构能够很快生成。但是因为这个新的特性会有一些其他的特性被添加进来来限制由于传递性依赖所引入的包。

依赖调节：如果在一个项目里面出现不同的模块，依赖了一个项目的不同版本的时候判断依赖的版本。Maven 的时候仅仅支持最近原则也就是在依赖树中的最靠近项目的版本作为依赖版本。到了 Maven 的时候又提出了一个最先声明原则，也就是在项目中被最早声明的被判断为依赖的版本。

同一个 jar 包，又会有不同的版本，当你所依赖的 jar 有不同的版本的时候，比如你的 A 项目: `A -> B -> C -> D 2.0 and A -> E -> D 1.0`。这就出现了冲突，你当然也可以再 A 里面配置指定依赖 D2.0。如果你没在 A 的 pom 里面配置指定用哪一个。maven 会替你找一个近的，即 D1.0。

## Excluded & Optional Dependencies | 排除依赖于可选依赖

可选依赖使用的情况是对于某个依赖来说系统只有在某个特定的情况下使用到它。例如数据库驱动，有 mysql 的，oracle 的。只有在我们使用到 mysql 的时候才会被使用。

# 排包

再次回顾下 Maven 中的包依赖规则如下：

- compile（默认使用）：编译依赖范围，编译、测试、运行都生效；
- test：测试依赖范围，只在测试的 classpath 有效，比如我们常用的 JUnit；
- provided：只对编译和测试有效，对运行无效，常用于容器提供了的运行环境；
- runtime：运行时依赖范围，比如 JDBC 驱动，编译和测试时不需要，只需要使用 JDK 提供的 JDBC 接口；
- system：系统依赖范围，依赖 Maven 仓库以外的依赖。

## 仲裁规则

- 第一原则：路径最短优先选中，将 pom 文件默认为一个树形结构，路径节点从根出发。

假设：路径 1 是：A->B->C->D(version1.0)，路径 2 是：A->B->D(version2.0)。由于路径 2 的长度小于路径 1，所以结果就是 A 会传递性依赖 D(version2.0)，当路径长度相等的时候，使用第二原则

- 第二原则：先声明者优先原则

当路径长度相同时候，就要使用第二原则。假设：路径 1 不变依然是：A->B->C->D(version1.0)，路径 2 是：A->B->E->D(version2.0)，由于路径 1 在路径 2 前面声明，所以结果就是 A 会传递性依赖 D(version1.0)。

- 第三原则：冲突 jar 句柄顺序随机原则

如果系统自己已经在 target 目录中加载了有冲突的 jar 包，并且机器有一定概率可以启动成功，主要是当打包的时候包会打印到 target 目录中，编译机器和目标机器执行了打包上传解压，在这个过程中就会引起互相冲突的 jar 在目标机器上排序，系统启动的时候，加载包的顺序就是随机的。

## 项目排包

`mvn dependency:tree>tree.log` 直接执行这个命令，基本上只能先优先看一下总体的依赖状况，做整体评估，然后根据系统日志报错信息反查。

- 启动时直接报错，java.lang.ClassNotFoundException ,或者方法不存在：这种比较简单，直接查找该类在哪个包中，相互冲突的基本上在两个 jar 包内就可以确定，基本手段：排除低版本，选择和自己 Java 代码一致使用的，排除和业务代码无关的。

- 类路径长度统计，版本就高不就低。这点需要找到有疑似冲突的，做一个简单的统计，常常新版本的会解决之前的问题，但是也有一个潜在的风险，高版本的可能引入了更多有可能的冲突，因此，高版本的尽量遵循业务无关的类库，如果和业务有关，尽量把两个版本的依赖树都保存以做比对，或者和具体业务负责人确认改动点。

- 隐含错误加上调试参数：`mvn +X dependency:tree>tree.log`，这样根据报错信息可以更精确的定位到错误或者冲突。
